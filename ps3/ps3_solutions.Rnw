\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{xcolor}
\usepackage{listings}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}

\title{Problem Set 3}
\author{Alexander Brandt\\SID: 24092167}
\date{September 30 2015}

\begin{document}

\maketitle

\section{Debugging Reading}

I chose to read option ii) as I am a huge fan of the Software Carpentry Foundation, as well as Titus Brown's work in general.  My question was ``After reading the Software Carpentry Foundation's paper on 'Best Practices for Scientific Computing', I found myself wondering about section 9, which says 'Document design and purpose, not mechanics.'  When is code written in such a way that it is self-evident to an outside reader/developer?  What are the hallmarks of code written in this style?  I think the suggestion has good intentions, but often discerning the difficulty level associated block of code is challenging for developers.  One person's 'easy' is often another person's 'hard,' and so in this way applying the principle of "the onerous should always be on the author to convince his or her peers of that" seems to be to be a recipe for disaster in the hands of some very well-meaning scientific programmers that I know that have forgotten how difficult it can be to work within a certain language, leading to less commentary and comprehension, not more.  For example, would explaining a choice of data structure in a language (a dict vs. a list in Python, for example) be violating this principle?''


\section{An Analysis of the Presidental Election Debates}

My question is: 
<<>>=
library(stringr)
library(XML)
library(curl)

split_block <- function (list_of_strings_solid) {
  current_name = ""
  current_block = ""
  my_list = list()
  list_of_strings <- unlist(strsplit(list_of_strings_solid,"\n"))
  # XML example class notes -- different HTML features
  for (i in 1:length(list_of_strings)) {
    if (((toupper(list_of_strings[[i]]) == list_of_strings[[i]]) &&
         !grepl("^\\([A-Z]+\\)$",list_of_strings[[i]]))) {
      # This is a "caps line" which doesn't contain useful information about
      # the text of the debate.  Mostly filler
      next
    }
    if (grepl("END",list_of_strings[[i]])) { break }
    name <- str_match(list_of_strings[[i]],regex("([A-Z]+):"))[,2]
    if ((!is.na(name)) && name != current_name) {
      if (current_name != "") {
        my_list[[current_name]] <- c(my_list[[current_name]],
        str_replace_all(current_block,paste(current_name,": ",sep=""),
        ""))
      }
      current_name <- name
      current_block <- ""
      # ... and maybe add a new block to the list?
    }
    if (length(current_name) != 0) {
      if (current_block != "") {
        current_block <- paste(current_block,
                               list_of_strings[[i]], sep=" ")
      }
      else {
        current_block <- list_of_strings[[i]]
      }
    }
  }
  my_list[[current_name]] <- c(my_list[[current_name]], 
  str_replace_all(current_block,
                  paste(current_name,": ",sep=""),""))
  return(my_list)
}

create_debate_text <- function(file_url)
{
  xml_handle <- htmlParse(file_url)
  v <- xpathSApply(xml_handle,
                   "//div[@id = 'content-sm']",xmlValue)
  text_data <- lapply(v,str_replace_all,
                      "([A-Z]+:)","\n\n\\1")
  return(text_data[[1]])
}

debate_summary <- function(file_url)
{
text_data <- create_debate_text(file_url)

events = list()
debate_blocks <- split_block(text_data)
for (n in names(debate_blocks))
{
   events[[n]] <- table(
     str_extract_all(
       paste(debate_blocks[[n]],collapse=" ")
       ,"\\([A-Za-z]+\\)"))
   debate_blocks[[n]] <- lapply(debate_blocks[[n]],
                                str_replace_all,
                                "\\([A-Za-z]+\\)","")
}

words = list()
sentence = list()
word_counts = list()
patterns = c("I[^a-zA-Z]", "we[^a-zA-Z]", "America(n)?[^a-zA-Z]", 
             "democra(cy|tic)[^a-zA-Z]", "republic[^a-zA-Z]",
             "Democrat(ic)?[^a-zA-Z]","Republican[^a-zA-Z]",
             "free(dom)?[^a-zA-Z]", "war[^a-zA-Z]",
             "God(?! bless)[^a-zA-Z]",
             "(Jesus|Christ|Christian)[^a-zA-Z]",
             "God bless[^a-zA-Z]")
for (n in names(debate_blocks))
{
  to_analyze <- paste(debate_blocks[[n]],collapse=" ")
  for (pattern in patterns)
  {
    word_counts[[n]][[pattern]] <- str_count(to_analyze,pattern)
  }
  names(word_counts[[n]]) <- c("I","we","America{n}",
                               "democra{cy,tic}","republic",
                               "Democrat{,ic}","Republican",
                               "free{,dom}","war",
                               "God (only)","God Bless",
                               "{Jesus, Christ, Christian}")
  # print(word_counts)
  words[[n]] <- str_extract_all(to_analyze,
'(([:alpha:]+(\'([:alpha:]+)?)?)|([:digit:]+(,([:digit:]+)?)?))')
  sentence[[n]] <- str_extract_all(to_analyze,
"([:alpha:])(([:alpha:]|[:space:]|[:digit:]|\'|,|-)*)(\\.|\\?|\\!)")
  print(paste("The average word length of ",
              n,"'s speach is:",sep = ""))
  print(mean(rapply(words[[n]],nchar)))
  print(paste("The number of characters (in the words) in ",
              n,"'s speach is:",sep = ""))
  print(sum(rapply(words[[n]],nchar)))
  print(paste("The number of words in ", n,"'s speach is:",
              sep = ""))
  print(length(unlist(words[[n]])))
  print(paste("The buzzwords in ", n,"'s speach is:",
              sep = ""))
  print(word_counts[[n]])
  print(paste("Event occurences in ", n,"'s speach is:",
              sep = ""))
  print(events[[n]])
}
return(debate_blocks)
}

menu_url="http://www.debates.org/index.php?page=debate-transcripts"
menu_xml_handle <- htmlParse(menu_url)
menu_nodes <- getNodeSet(menu_xml_handle,"//a[@href]")
all_debate_links <- xpathSApply(
  menu_xml_handle, "//a[@href]", xmlGetAttr, 'href')
years <- c("2012","2008","2004","2000","1996")

year_reg <- paste("(",
                  paste(paste(years,collapse="|"),
                        ").+(First)",
                        sep=""),
                  sep="")

my_debate_links <- all_debate_links[grepl(
  year_reg,
  sapply(menu_nodes,xmlValue))]
debate_blocks_list = list()
i <- 1
for (year in years)
{
  print(paste("The statistics for the first debate in",year,"..."))
  debate_blocks_list[[year]] <- debate_summary(my_debate_links[i])
  i <- i + 1
  cat("\n\n")
}
@

\section{Practice with S4 -- Illustrating a Random Walk}

<<>>=
rw <- setClass(
  "rw",
  # The basic slots associated with our class
  slots = c(
    start = "numeric",
    steps   = "numeric",
    trajectory_recording = "logical",
    .trajectory = "matrix"),
  
  # Now we declare our default values
  prototype=list(
    start = c(0,0),
    #steps = 10,
    trajectory_recording = TRUE
  ),
  # Look for things that might be amiss
  validity=function(object)
  {
    # REMEMBER TO ADD INTEGER CHECKS.
    if(object@steps<0) {
      return("Please enter 
             a positive number of steps.")
    }
    if(as.integer(object@steps)!=object@steps) {
      return("Please enter 
             an integer valued number of steps.")
    }
    if(length(object@start)!=2) {
      return("This program is
             only written for 2D (for now!).")
    }
    return(TRUE)
  }
)


# Found "OOP in R" (http://practicalcomputing.org/node/80) to be very useful.
setGeneric("start<-", function(self, value) standardGeneric("start<-"))

setReplaceMethod("start",
  "rw",
  function(self,value) {
  self@start <- value
  self
  }
)

setMethod(
  f="[",
  signature="rw",
  definition=function(x,i,drop){
    mypath=slot(x,".trajectory");
    xs=sum(mypath[1:i,1]);
    ys=sum(mypath[1:i,2]);
    return(c(x@start[1]+xs, x@start[2]+ys))
  }
)

setMethod(
  f="plot",
  signature="rw",
  definition=function(x){
    mypath=slot(x,".trajectory");
    xs=cumsum(mypath[,1]);
    ys=cumsum(mypath[,2]);
    plot(x@start[2]+ys,x@start[1]+xs, type='o');
  }
)

setMethod(
  f="print",
  signature="rw",
  definition=function(x){
    print("Starting position:")
    print(slot(x,"start"))
    print("After this many steps...:")
    print(slot(x,"steps"))
    print("We arrive at:")
    print(x[slot(x,"steps")])
    if (slot(x,"trajectory_recording"))
    { for (i in 1:slot(x,"steps")) {
        print(x[i]) }}
  }
)

setGeneric("simulate", 
           function(.Object){standardGeneric("simulate")})

setMethod(
  f="simulate",
  signature="rw",
  definition=function(.Object){
    slot(.Object,".trajectory") <- 
      matrix(c(0, 1, -1, 0, 1, 0, 0, -1), 
             nrow=4, 
             ncol=2)[sample(4,size=slot(.Object,"steps"),
             replace=TRUE),];
    return(.Object)
  }
)

# Testing the replacement class
my_walk <- new("rw", start=c(1,1),steps=1000,trajectory_recording=FALSE)
# To circumvent this, I would need to use the "assign" function, which
# the S4 manual cautions against! 
# (https://cran.r-project.org/doc/contrib/Genolini-S4tutorialV0-5en.pdf)
my_walk <- simulate(my_walk)
my_walk[50]
plot(my_walk)
start(my_walk)<-c(100,100)
plot(my_walk)
print(my_walk)
@

\end{document}